---
title: "Automatisation du traitement des courbes de charge"
author: "Ilyas EL BOUJADAINI"
date: "`r Sys.Date()`"
output: html_document
---

Ce projet s'articule en plusieurs phases

-   Phase 0 : Traitement de données simulées
-   Phase 1 : Traitement de données réelles par interpolation linéaire
-   Phase 2 : Correction de données réelles avec adaptation de la méthode de traitement

# Phase 0 : Données simulées

## 00_constant_data_simul.py

Ce script simule des données de charge électrique avec un pas de temps régulier (choisi) entre deux dates (choisies).

Pour cela on importe les modules Python nécessaires:
```{python}
import os
import datetime as dt
import random as rd
import pandas as pd
```

- os : sert à créer un chemin d'exportation dans le répertoire du projet
- datetime : ce module formate les dates au format datetime, permettant de préciser chaque élément des dates (année, mois, jour, heure, ...)
- random : permet de choisir aléatoirement des valeurs de puissance dans une liste de valeurs
- pandas : permet d'étudier des tableaux sous forme de dataframes, plus simples à manipuler et avec un temps d'exécution plus faible

La génération de données repose sur la fonction create_const_csv_data() :
```{python}
def create_const_csv_data(start_time: dt.datetime, end_time: dt.datetime,
                          time_step: int, data: list):
    simul = pd.DataFrame(columns=['date', 'puissance_w'])
    time = start_time

    while time < end_time:
        line = [time, data[rd.randint(0, len(data) - 1)]]
        simul.loc[len(simul)] = line
        time += dt.timedelta(minutes=time_step)

    output_path = os.path.join('input', '00_simulation_' + str(time_step)
                               + 'min_const.csv')
    simul.to_csv(output_path, sep=',', index=False, header=True,
                 encoding='utf-8')
```

Cette fonction prend 4 arguments:

- start_time : la date de début au format datetime, antérieure à end_time
- end_time : la date de fin au format datetime, postérieure à start_time
- time_step : le pas temporel souhaité en minutes, entier
- data : liste qui contient les valeurs possibles de puissance en W

Elle ne renvoie pas de résultat.

En premier on crée le dataframe simul qui enregistrera les données à exporter,
et la variable time qui prend la valeur de start_time, et qui servira d'indice à
l'itération.

Ensuite avec une boucle while qui prend comme condition que la date de fin <u>ne
soit pas atteinte</u> (time < end_time), on crée une liste nommée line de 2
éléments avec la variable time et une valeur de data choisie en réalisant un
<u>tirage aléatoire parmi les indices de la liste</u> avec le module random
(data[<u>rd.randint(0, len(data) - 1)]</u>), on ajoute cette liste line à la
liste simul (simul.loc[len(simul)] = line), et on ajoute à time <u>le pas
temporel en minutes</u> (time += dt.timedelta(<u>minutes=time_step</u>))

Une fois que la boucle finit ses itérations, on crée un chemin d'exportation 
pour le ficher CSV avec la variable output_path. On utilise la méthode 
os.path.join() pour adapter le chemin à l'OS de l'utilisateur. Comme le fichier 
exporté sera étudié par la suite, on exporte le résultat dans le sous-répertoire
input, à la différence des autres scripts qui exportent tous dans output.

Enfin, on exporte la liste simul au format CSV avec la bibliothèque pandas.

Maintenant que la fonction est définie , on peut choisir une date de début,
une date de fin et une liste de valeurs possibles.
```{python}
data = [1000, 2000, 3000, 4000, 5000, 6000]
start_time = dt.datetime(2023, 1, 1)
end_time = dt.datetime(2024, 1, 1)

create_const_csv_data(start_time=start_time, end_time=end_time, time_step=20,
                      data=data)
```

## 01_simul_data_analysis.py

Ce script se sert des données générées dans le script 00_constant_data_simul.py
et génère un tableau des moyennes journalières de puissance sur la période
étudiée
```{python}
import os
import pandas as pd
```
On importe d'abord les librairies os et pandas vues précédemment, pour les mêmes
usages, c'est-à-dire adaptation à l'OS utilisateur, création de chemins et manipulation de
dataframes.

```{python}
import sys
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath('__file__')))
tools_dir = os.path.join(parent_dir, 'tools')
sys.path.append(tools_dir)
import delimiter as dlmt
```
Ensuite, à l'aide du module sys, on importe le script delimiter.py qui détecte
le séparateur du CSV étudié.

```{python}
entry_path = os.path.join('input', '00_simulation_20min_const.csv')
delimiter = dlmt.detect_delimiter(entry_path)
simul = pd.read_csv(entry_path, sep=delimiter)
simul['date'] = pd.to_datetime(simul['date'].str.split('+').str[0],
                               format="%Y-%m-%d %H:%M:%S")
print(simul.head(5))
```

